diff --git a/storage/innobase/include/lock0lock.h b/storage/innobase/include/lock0lock.h
index 90593d791a7..7eb94e0db2d 100644
--- a/storage/innobase/include/lock0lock.h
+++ b/storage/innobase/include/lock0lock.h
@@ -45,6 +45,8 @@ class ReadView;
 
 extern my_bool	innobase_deadlock_detect;
 
+extern const ulint kNumShards;
+
 /*********************************************************************//**
 Gets the size of a lock struct.
 @return size in bytes */
diff --git a/storage/innobase/include/trx0trx.h b/storage/innobase/include/trx0trx.h
index 5edfa35246f..f84c31799a7 100644
--- a/storage/innobase/include/trx0trx.h
+++ b/storage/innobase/include/trx0trx.h
@@ -1264,6 +1264,8 @@ struct trx_t {
 					error, or empty. */
 	FlushObserver*	flush_observer;	/*!< flush observer */
 
+	bool		*has_locks;
+
 #ifdef UNIV_DEBUG
 	bool		is_dd_trx;	/*!< True if the transaction is used for
 					doing Non-locking Read-only Read
diff --git a/storage/innobase/lock/lock0lock.cc b/storage/innobase/lock/lock0lock.cc
index d14a5c7a0fa..d50fc77a6d5 100644
--- a/storage/innobase/lock/lock0lock.cc
+++ b/storage/innobase/lock/lock0lock.cc
@@ -66,6 +66,21 @@ static const ulint	TABLE_LOCK_CACHE = 8;
 /** Size in bytes, of the table lock instance */
 static const ulint	TABLE_LOCK_SIZE = sizeof(ib_lock_t);
 
+const ulint kNumShards = 5;
+pthread_rwlock_t *rec_locks;
+
+static
+void
+lock_shard(
+	ulint type_mode,
+	ulint space,
+	ulint page_no,
+	ulint heap_no,
+	trx_t	*trx)
+{
+
+}
+
 /** Deadlock checker. */
 class DeadlockChecker {
 public:
@@ -453,6 +468,11 @@ lock_sys_create(
 	lock_sys->prdt_hash = hash_create(n_cells);
 	lock_sys->prdt_page_hash = hash_create(n_cells);
 
+	rec_locks = reinterpret_cast<pthread_rwlock_t *>(ut_malloc_nokey(sizeof(pthread_rwlock_t)));
+	for (ulint i = 0; i < kNumShards; i++) {
+		*(rec_locks[i]) = PTHREAD_RWLOCK_INITIALIZER;
+	}
+
 	if (!srv_read_only_mode) {
 		lock_latest_err_file = os_file_create_tmpfile(NULL);
 		ut_a(lock_latest_err_file);
@@ -555,6 +575,11 @@ lock_sys_close(void)
 		}
 	}
 
+	for (ulint i = 0; i < kNumShards; i++) {
+		pthread_rwlock_destroy(rec_locks[i]);
+	}
+
+	ut_free(rec_locks);
 	ut_free(lock_sys);
 
 	lock_sys = NULL;
diff --git a/storage/innobase/trx/trx0trx.cc b/storage/innobase/trx/trx0trx.cc
index 07bb8701485..2f38519bf0e 100644
--- a/storage/innobase/trx/trx0trx.cc
+++ b/storage/innobase/trx/trx0trx.cc
@@ -474,6 +474,8 @@ trx_create_low()
 	/* Remember to free the vector explicitly in trx_free(). */
 	trx->autoinc_locks = ib_vector_create(alloc, sizeof(void**), 4);
 
+	trx->has_locks = ut_zalloc_nokey(sizeof(bool) * kNumShards);
+
 	/* Should have been either just initialized or .clear()ed by
 	trx_free(). */
 	ut_a(trx->mod_tables.size() == 0);
@@ -511,6 +513,8 @@ trx_free(trx_t*& trx)
 
 	trx_pools->mem_free(trx);
 
+	ut_free(trx->has_locks);
+
 	trx = NULL;
 }
 
